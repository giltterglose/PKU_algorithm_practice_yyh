# 第二章：简单计算与模拟

现在就开始写代码来做了。

## 案例一：鸡兔同笼问题

问题背景：

一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。

输入的数据：

一行，一个正整数a (a < 32768)。

输出的数据：

一行，包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开。
如果没有满足要求的答案，则输出两个0，中间用一个空格分开。

解题思路：由于用穷举的方法就时间复杂度很高，时间开销大，那就经过分析，就发现，题目要求最小的数目和最大的数目，最小的数目就是让兔子数目最多，最大的数目就是让鸡的数目最多，但是上述条件就是在为偶数情况下才成立。但是如果说奇数就不成立。

所以：

当n为4的倍数，最小就是都是兔子数目，最大就是都是鸡的数目。

当n为2的倍数，最小就是腿的数目/4+1，最大数目就是都是鸡的数目。

n为奇数表示不存在。

这题时间复杂度为常数O(1)。就可以在较短时间之内完成。

## 案例二：校门外的树

背景介绍：

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

输入：

第一行有两个整数L（1 <= L <= 10000）和 M（1 <= M <= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。

对于20%的数据，区域之间没有重合的部分；
对于其它的数据，区域之间有重合的情况。

输出：

包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。

解题思路：这一题不能像上一个题目一样来直接求解，需要进行模拟。首先定义一个状态数值标明这里的树是否存在，如果存在，就标记为true，否则为false。然后就根据起始端点进行挖掘，如果说是true，就可以挖掘，然后那个点被标记成false，然后统计被挖掉的树的个数。可以防止重复，周而复始，最终用长度+1减去挖去的数目就计算出来了。

## 案例三：装箱问题

问题背景描述：

一个工厂制造的产品形状都是长方体，它们的高度都是h，长和宽都相等，一共有六个型号，他们的长宽分别为1*1, 2*2, 3*3, 4*4, 5*5, 6*6。这些产品通常使用一个 6*6*h 的长方体包裹包装然后邮寄给客户。因为邮费很贵，所以工厂要想方设法的减小每个订单运送时的包裹数量。他们很需要有一个好的程序帮他们解决这个问题从而节省费用。现在这个程序由你来设计。

输入：

输入文件包括几行，每一行代表一个订单。每个订单里的一行包括六个整数，中间用空格隔开，分别为1*1至6*6这六种产品的数量。输入文件将以6个0组成的一行结尾。

输出：

除了输入的最后一行6个0以外，输入文件里每一行对应着输出文件的一行，每一行输出一个整数代表对应的订单所需的最小包裹数。

解题思路，这一题看起来就有些复杂了，就需要进行分析，但是很长时间都没有想出来，就看了一下书，就书上是这么说的：

首先将长和宽大于3x3的产品放入箱子中，然后比较2x2的空位和长宽为2x2的产品的数量。如果空位较多，就把产品放入空位里面，然后多出的装1x1的产品，空位较少，就打开新的箱子装2*2的，然后安排剩下的装1x1的产品，然后把剩余的1x1装入新的箱子里面。

代码就参考了写了一下。

## 案例四、约瑟夫问题

问题背景：

约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，编程求输入ｎ，ｍ后，输出最后猴王的编号。

输入：

每行是用空格分开的两个整数，第一个是 n, 第二个是 m ( 0 < m,n <=300)。最后一行是： 0 0

输出：

对于每行输入数据（最后一行除外)，输出数据也是一行，即最后猴王的编号。

解题思路：这一题主要是标记状态，和前面一个题目类似（需要移走的树），标记哪些猴子还在现场，哪些猴子已经淘汰出局了，就进行如循环队列一样进行，只不过是统计之时不考虑已经淘汰的猴子了。计数器就直接跳过就行。

## 案例五、排列

问题背景：

题目描述：
大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。

任务描述：
给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。
比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。

输入：

第一行是一个正整数m，表示测试数据的个数，下面是m组测试数据，每组测试数据第一行是2个正整数n( 1 <= n < 1024 )和k(1<=k<=64)，第二行有n个正整数，是1，2 … n的一个排列。

输出：

对于每组输入数据，输出一行，n个数，中间用空格隔开，表示输入排列的下k个排列。

由于这一题分析起来有些复杂，我就暂时没有写了，我先做容易的部分。

## 案例六、与7无关的数

问题描述：

一个正整数,如果它能被7整除,或者它的十进制表示法中某一位上的数字为7,则称其为与7相关的数.现求所有小于等于n(n < 100)的与7无关的正整数的平方和.

输入数据：

输入为一行,正整数n(n < 100)

输出数据：

输出一行，包含一个整数，即小于等于n的所有与7无关的正整数的平方和。

解题思路：

这一题由于是判断小于100的数，就直接与7不相关（求余于7不为0，个位或者10位不包括7）的数，把它们加起来就可以了。

## 案例七、判断闰年

问题描述：

判断某年是否是闰年。

输入：

输入只有一行，包含一个整数a(0 < a < 3000)

输出：

一行，如果公元a年是闰年输出Y，否则输出N

注意这个条件：公历纪年法中，能被4整除的大多是闰年，但能被100整除而不能被400整除的年份不是闰年， 能被3200整除的也不是闰年，如1900年是平年，2000年是闰年，3200年不是闰年。按照这个条件写分支即可。

## 案例八、求一元二次方程的根

问题描述：

利用公式x1 = (-b + sqrt(b*b-4*a*c))/(2*a), x2 = (-b - sqrt(b*b-4*a*c))/(2*a)求一元二次方程ax2+ bx + c =0的根，其中a不等于0。

输入：

输入一行，包含三个浮点数a, b, c（它们之间以一个空格分开），分别表示方程ax2 + bx + c =0的系数。

输出：

输出一行，表示方程的解。
若b2 = 4 * a * c,则两个实根相等，则输出形式为：x1=x2=...。
若b2 > 4 * a * c,则两个实根不等，则输出形式为：x1=...;x2 = ...，其中x1>x2。
若b2 < 4 * a * c，则有两个虚根，则输出：x1=实部+虚部i; x2=实部-虚部i，即x1的虚部系数大于等于x2的虚部系数，实部为0时不可省略。实部 = -b / (2*a), 虚部 = sqrt(4*a*c-b*b) / (2*a)

所有实数部分要求精确到小数点后5位，数字、符号之间没有空格。

解题思路：z注意浮点数，根据式子来写就行。

## 案例九、合唱队形

问题描述：

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。

合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足T1<...<Ti>Ti+1>…>TK(1<=i<=K)。

你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

输入：

输入的第一行是一个整数N(2<=N<=100)，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti(130<=Ti<=230)是第i位同学的身高(厘米)。

输出：

输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

解题思路：这题涉及动态规划问题，等到动态规划学了再写。

## 归纳总结

本章作为算法的初步，就是遇到问题要怎么通过问题去进行建模解决实际问题。学习算法的首先就是熟悉算法的步骤，怎样通过问题设计算法与编码即可。